parent: [[Кодирование категориальных данных с помощью pandas]]

tags: #reading #book_club #ohe

Когда мы кодируем категориальные признаки числами, модель может думать, что признаки с бОльшими числовыми значениями имеют бОльшую значимость. Из-за этого модель может обучаться и работать неоптимально. Общепринятым решением такой проблемы является one-hot encoding (кодирование с одним активным состоянием). Суть подхода заключается в том, чтобы создать фиктивные признаки для каждого уникального значения среди именных признаков. 

Если взять вместо признака `color` взять три новых признака `blue`, `green` и `red`, то для каждого образца один из таких признаков будет равен 1, а остальные 0. То есть, например, синий цвет кодировался бы как `blue=1, green=0, red=0`. В sklearn для такого кодирования есть специальный класс `OneHotEncoder`:

```python
from sklearn.preprocessing import OneHotEncoder

X = df[['color', 'size', 'price']].values
color_ohe = OneHotEncoder()
print(color_ohe.fit_transform(X[:, 0].reshape(-1, 1)).toarray())
```

Output:

```output
array([[0., 1., 0.],
       [0., 0., 1.],
       [1., 0., 0.]])
```

Обратите внимание, что мы применили `OneHotEncoder` только к единственному столбцу, `Х[:, 0].reshape(-1, 1))`, чтобы избежать модификации остальных двух столбцов в массиве.

Если нужно выборочно трансформировать столбцы в массиве с множеством признаков, можно использовать класс `ColumnTransformer`, который принимает список кортежей `(name, transformer, column(s))`:

```python
from sklearn.compose import ColumnTransformer

Х = df[['color', 'size', 'price']] .values
c_transf = ColumnTransformer([
    ('onehot', OneHotEncoder(), [0]),
    ('nothing', 'passthrough', [1, 2]) 
])

print(c_transf.fit_transform(X).astype(float))
```

Output:

```output
array([[ 0. ,  1. ,  0. ,  1. , 10.1],
       [ 0. ,  0. ,  1. ,  2. , 13.5],
       [ 1. ,  0. ,  0. ,  3. , 15.3]])
```

Посредством аргумента `'passthrough'` мы указали, что желаем модифицировать только первый столбец и оставить другие два столбца незатронутыми.

Еще более удобный способ создания таких фиктивных признаков через one-hot encoding предполагает использование метода `get_dummies`, реализованного в pandas. Будучи примененным к объекту DataFrame, метод преобразует только строковые столбцы и оставит все остальные столбцы неизмененными:

```pyhton
pd.get_dummies(df[['price', 'color', 'size']])
```

Output: 

![[Screenshot 2023-12-10 at 13.59.01.png]]

При использовании закодированных унитарным кодом наборов данных нужно помнить, что они привносят [[Мультиколлинеарность признаков|мультиколлинеарность]], которая может стать проблемой для определенных методов (например, методов, требующих обращения матриц). Если признаки сильно взаимосвязаны, тогда обращать матрицы будет трудно в вычислительном плане, что может привести к получению численно неустойчивых оценок. Чтобы сократить взаимосвязь между переменными, мы можем просто удалить один столбец признака из закодированного массива методом one-hot encoding. Обратите внимание, что в результате удаления столбца признака мы не теряем какую-то важную информацию. Скажем, после удаления столбца `color_blue` информация признака все равно сохраняется, т.к. из наблюдения `color_green=O` и `color_red=O` вытекает, что цветом должен быть bluе.

Если мы применяем функцию `get_dummies`, то можем удалить первый столбец, указав True для параметра `drop_first`:

```python
pd.get_dummies(df[['price', 'color', 'size']], drop_first=True)
```

Output:

![[Screenshot 2023-12-10 at 14.07.46.png]]

Чтобы удалить избыточный столбец через `OneHotEncoder`, нам необходимо установить `drop='first'` и `categories='auto'`:

```python
color_ohe = OneHotEncoder(categories='auto', drop='first')
с_transf = ColumnTransformer ([('onehot', color_ohe, [0]), ('nothing', 'passthrough', (1, 2))])

c_transf.fit_transform(X).astype(float)
```

Output:

```output
array([[ 0. ,  1. ,  0. ,  1. , 10.1],
       [ 0. ,  0. ,  1. ,  2. , 13.5],
       [ 1. ,  0. ,  0. ,  3. , 15.3]])
```

