parent: [[Глава 1. Введение в паттерны проектирования]]

tags: #OOP #book #pattern 

#### [[Abstract Factory (абстрактная фабрика)]]

Интерфейс для создания семейств связанных между собой или зависимых объектов без указания их конкретных классов.
#### [[Adapter (адаптер)]]

Преобразует интерфейс класса в другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, которая была бы невозможна без данного паттерна из-за несовместимости интерфейсов.
#### [[Bridge (мост)]]

Отделяет абстракцию от реализации, чтобы их можно было изменять независимо друг от друга.
#### [[Builder (строитель)]]

Отделяет конструирование сложного объекта от его представления, чтобы один процесс конструирования мог использоваться для создания различных представлений.
#### [[Chain of Responsibility (цепочка обязанностей)]]

Можно избежать формирования жесткой связи между отправителем запроса и его получателем, для чего возможность обработки запроса предоставляется нескольким объектам. Объекты-получатели объединяются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-либо объектом.
#### [[Command (команда)]]

Инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов по типу запроса, ставить запросы в очередь, протоколировать их и поддерживать отмену выполнения операций.
#### [[Composite (компоновщик)]]

Группирует объекты в древовидные структуры для представления иерархий типа «часть — целое». Позволяет клиентам работать с единичными объектами так же, как с группами объектов.
#### [[Decorator (декоратор)]]

Динамически наделяет объект новыми обязанностями. Декораторы применяются для расширения существующей функциональности и являются гибкой альтернативой порождению подклассов.
#### [[Facade (фасад)]]

Предоставляет унифицированный интерфейс к набору интерфейсов в некоторой подсистеме. Определяет интерфейс более высокого уровня, облегчающий работу с подсистемой.
#### [[Factory Method (фабричный метод)]]

Определяет интерфейс для создания объектов, позволяя подклассам решить, экземпляр какого класса следует создать. Позволяет классу передать ответственность за создание экземпляра в подклассы.
#### [[Flyweight (приспособленец)]]

Применяет механизм совместного использования для эффективной поддержки большого числа мелких объектов.
#### [[Interpreter (интерпретатор)]]

Для заданного языка определяет представление его грамматики вместе с интерпретатором, который использует представление для интерпретации предложений языка.
#### [[Iterator (итератор)]]

Дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутреннего представления.
#### [[Mediator (посредник)]]

Определяет объект, в котором инкапсулирована информация о взаимодействии объектов из некоторого множества. Способствует ослаблению связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою очередь, дает возможность независимо изменять схему взаимодействия.
#### [[Memento (хранитель)]]

Позволяет без нарушения инкапсуляции получать и сохранять во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить в точно таком же состоянии.
#### [[Observer (наблюдатель)]]

Определяет между объектами зависимость типа «один-ко-многим», так что при изменении состояния одного объекта все зависящие от него получают уведомление и автоматически обновляются.
#### [[Prototype (прототип)]]

Описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования.
#### [[Proxy (заместитель)]]

Подменяет другой объект для контроля доступа к нему.
#### [[Singleton (одиночка)]]

Гарантирует, что некоторый класс может существовать только в одном экземпляре, и предоставляет глобальную точку доступа к нему.
#### [[State (состояние)]]

Позволяет объекту изменять свое поведение при модификации внутреннего состояния. При этом все выглядит так, словно поменялся класс объекта.
#### [[Strategy (стратегия)]]

Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Позволяет менять алгоритм независимо от клиента, который им пользуется.
#### [[Template Method (шаблонный метод)]]

Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять отдельные шаги алгоритма, не меняя его общей структуры.
#### [[Visitor (посетитель)]]

Представляет операцию, которую надо выполнить над элементами объектной структуры. Позволяет определить новую операцию без изменения классов элементов, к которым он применяется.