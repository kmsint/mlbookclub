parent: [[Как решать задачи с помощью паттернов]]

tags: #OOP #book #pattern 

Системы должны проектироваться с учетом их дальнейшего развития. Для проектирования системы, устойчивой к таким изменениям, следует предположить, как она будет изменяться на протяжении отведенного ей времени жизни.

Если при проектировании системы не принималась во внимание возможность изменений, то есть вероятность, что в будущем ее придется полностью перепроектировать.

#### Типичные причины перепроектирования

- *при создании объекта явно указывается класс.* Задание имени класса привязывает вас к конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно. Паттерны проектирования: [[Abstract Factory (абстрактная фабрика)|абстрактная фабрика]], [[Factory Method (фабричный метод)|фабричный метод]], [[Prototype (прототип)|прототип]];

- *зависимость от конкретных операций.* Задавая конкретную операцию, вы ограничиваете себя единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения. Паттерны проектирования: [[Chain of Responsibility (цепочка обязанностей)|цепочка обязанностей]], [[Command (команда)|команда]];

- *зависимость от аппаратной и программной платформ.* Внешние интерфейсы операционной системы и интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах. Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем так важно ограничивать платформенные зависимости. Паттерны проектирования: [[Abstract Factory (абстрактная фабрика)|абстрактная фабрика]], [[Bridge (мост)|мост]];

- *зависимость от представления или реализации объекта.* Если клиент располагает информацией о том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от каскадных изменений. Паттерны проектирования: [[Abstract Factory (абстрактная фабрика)|абстрактная фабрика]], [[Bridge (мост)|мост]], [[Memento (хранитель)|хранитель]], [[Proxy (заместитель)|заместитель]];

- *зависимость от алгоритмов.* Во время разработки и последующего использования алгоритмы часто расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, следует изолировать. Паттерны проектирования: [[Bridge (мост)|мост]], [[Iterator (итератор)|итератор]], [[Strategy (стратегия)|стратегия]], [[Template Method (шаблонный метод)|шаблонный метод]], [[Visitor (посетитель)|посетитель]];

- *сильная связанность.* Сильно связанные между собой классы трудно использовать порознь, так как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему трудно изучать, переносить на другие платформы и сопровождать. Для поддержки слабосвязанных систем в паттернах проектирования применяются такие методы, как абстрактные связи и разбиение на слои. Паттерны проектирования: [[Abstract Factory (абстрактная фабрика)|абстрактная фабрика]], [[Bridge (мост)|мост]], [[Chain of Responsibility (цепочка обязанностей)|цепочка обязанностей]], [[Command (команда)|команда]], [[Facade (фасад)|фасад]], [[Mediator (посредник)|посредник]], [[Observer (наблюдатель)|наблюдатель]];

- *расширение функциональности за счет порождения подклассов.* Специализация объекта путем создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса необходимо так же ясно представлять себе устройство родительского класса. Например, замещение одной операции может потребовать замещения и других. Замещение операции может оказаться необходимым для того, чтобы можно было вызвать унаследованную операцию. Кроме того, порождение подклассов ведет к разрастанию количества классов, поскольку даже для реализации простого расширения приходится создавать новые подклассы. Паттерны проектирования: [[Bridge (мост)|мост]], [[Chain of Responsibility (цепочка обязанностей)|цепочка обязанностей]], [[Composite (компоновщик)|компоновщик]], [[Decorator (декоратор)|декоратор]], [[Observer (наблюдатель)|наблюдатель]], [[Strategy (стратегия)|стратегия]];

- *неудобства при изменении классов.* Иногда нужно модифицировать класс, но делать это неудобно. Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками классов). Или любое изменение тянет за собой модификации множества существующих подклассов. Благодаря паттернам проектирования можно модифицировать классы и при таких условиях. Паттерны проектирования: [[Adapter (адаптер)|адаптер]], [[Decorator (декоратор)|декоратор]], [[Visitor (посетитель)|посетитель]].

Приведенные примеры демонстрируют гибкость, которую можно достичь, используя паттерны при проектировании приложений.

#### Основные типы программ и приоритеты

- Приложения
	- Переиспользование кода (помогут паттерны, уменьшающие число зависимостей)
	- Расширяемость
	- Удобство сопровождения
- Библиотеки
	- Переиспользование кода
- Фреймворки
	- Переиспользование дизайна, а не кода