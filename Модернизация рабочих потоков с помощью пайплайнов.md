parent: [[Освоение практического опыта оценки моделей и настройки гиперпараметров]]

tags: #ml #pipeline

В библиотеке `scikit-learn` есть специальный класс для удобного построения пайплайнов машинного обучения, который берет на себя всю работу по предварительной подготовке данных ([[Стандартизация признаков (standartization)|стандартизация признаков]], [[Приведение признаков к одному масштабу|масштабирование признаков]]). Класс так и называется `Pipeline`

### Объединение оценщиков (estimators) и преобразователей (transformers) в пайплайн

Поскольку признаки в наборе данных Breast Cancer Wisconsin измерены с разными масштабами, нам необходимо стандартизировать столбцы в нем, прежде чем мы сможем передать их линейному классификатору, например, на основе логистической регрессии. Кроме того, пусть мы хотим сжать данные от начальных 30 измерений до двумерного подпространства посредством [[Анализ главных компонентов (PCA - Principal Component Analysis)|анализа главных компонентов (РСА)]]

Вместо прохождения через шаги подгонки модели и трансформации данных для обучающего и тестового наборов по отдельности мы можем объединить объекты `StandardScaler`, `РСА` и `LogisticRegression` в конвейер:

```python
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline

pipe_lr = make_pipeline(StandardScaler(),
                        PCA(n_components=2),
                        LogisticRegression())

pipe_lr.fit(X_train, y_train)
y_pred = pipe_lr.predict(X_test)
test_acc = pipe_lr.score(X_test, y_test)
print(f'Test accuracy: {test_acc:.3f}')
```

![[Pasted image 20231223150848.png]]

Функция `make_pipeline` принимает произвольное количество преобразователей `scikit-learn` (объектов, поддерживающих методы `fit` и `transform`), за которыми следует оценщик `scikit-learn`, реализующий методы `fit` и `predict`. В предыдущем примере кода мы предоставили функции `make_pipeline` в качестве входа два преобразователя, `StandardScaler` и `РСА`, а также оценщик `LogisticRegression`, в результате чего `make_pipeline` создаст из них объект `Pipeline`.

Можно считать объект `Pipeline` из `scikit-learn` метаоценщиком или оболочкой вокруг индивидуальных преобразователей и оценщиков. Если мы вызовем метод `fit` объекта `Pipeline`, тогда данные будут передаваться последовательности преобразователей посредством обращений к `fit` и `transform` на промежуточных шагах, пока они не достигнут объекта оцен­щика (финального элемента конвейера). Затем оценщик произведет подгонку к трансформированным обучающим данным.

Когда в показанном выше коде мы выполняем метод `fit` на конвейере `pipe_lr`, объект `StandardScaler` сначала осуществляет вызовы методов `fit` и `transform` на обучающих данных. Затем трансформированные обучающие данные передаются следующему объекту в конвейере, т.е. `РСА`. Подобно предыдущему шагу объект `РСА` также выполняет методы `fit` и `transform` на масштабированных входных данных и передает их финальному элементу конвейера - оценщику.

Наконец, оценщик `LogisticRegression` обеспечивает подгонку к обучающим данным после того, как они были подвернуты трансформациям с помощью `StandardScaler` и `РСА`. На количество промежуточных шагов в конвейере никаких ограничений не накладывается, но последним элементом конвейера должен быть оценщик.

Аналогично методу `fit` в конвейерах также реализован метод `predict`. Если мы передадим набор данных методу `predict` объекта `Pipeline`, то данные пройдут через все промежуточные шаги посредством обращений к `transform`. На последнем шаге объект оценщика возвратит прогноз на трансформированных данных.

