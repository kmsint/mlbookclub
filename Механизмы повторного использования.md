parent: [[Как решать задачи с помощью паттернов]]

tags: #OOP #book #pattern 

Два наиболее распространенных приема повторного использования функциональности в объектно-ориентированных системах — это наследование класса и композиция объектов.

Наследование класса позволяет определить реализацию одного класса через другой. Повторное использование за счет порождения подкласса называют еще повторным использованием по принципу прозрачного ящика (white box reuse) - внутреннее устройство родительских классов часто видимо подклассам.

Композиция объектов — альтернатива наследованию класса. В этом случае новая, более сложная функциональность получается путем объединения или композиции объектов. Для композиции требуется, чтобы объединяемые объекты имели четко определенные интерфейсы. Такой способ называют повторным использованием по принципу черного ящика (blackbox reuse), поскольку детали внутреннего устройства объектов остаются скрытыми.

Предпочитайте композицию наследованию класса. С помощью делегирования композицию можно сделать столь же мощным инструментом повторного использования, сколь и наследование. При делегировании в процессе обработки запроса задействованы два объекта: получатель поручает выполнение операций другому объекту — уполномоченному (делегату). Примерно так же подкласс делегирует ответственность своему родительскому классу. Но унаследованная операция всегда может обратиться к объекту-получателю через переменную класса или переменную `self`. Чтобы достичь того же эффекта для делегирования, получатель передает указатель на самого себя соответствующему объекту, дабы при выполнении делегированной операции последний мог обратиться к непосредственному адресату запроса.

Делегирование — особый случай композиции. Оно показывает, что наследование как механизм повторного использования всегда можно заменить композицией.

#### Наследование и параметризованные типы

Еще один (хотя и не в точности объектно-ориентированный) метод повторного использования имеющейся функциональности — это применение параметризованных типов, известных также как обобщенные типы (Ada, Eiffel) или шаблоны (C++). Данная техника позволяет определить тип, не задавая типы, которые он использует. Отсутствующие типы передаются в параметрах в точке использования. Например, класс `List` (список) можно параметризовать типом помещаемых в список элементов. Чтобы объявить список целых чисел, вы передаете тип `integer` в качестве параметра параметризованному типу `List`. Если же надо объявить список строк, то в качестве параметра передается тип `String`. Для каждого типа элементов компилятор языка создаст отдельный вариант шаблона класса `List`.

Параметризованные типы предоставляют третий (после наследования класса и композиции объектов) способ комбинировать поведение в объектно-ориентированных системах. Многие задачи можно решить с помощью любого из этих трех методов.

Но между этими тремя подходами есть важные различия. Композиция объектов позволяет изменять поведение во время выполнения, но для этого требуются косвенные вызовы, что снижает эффективность. Наследование разрешает предоставить реализацию по умолчанию, которую можно замещать в подклассах. Параметризованные типы позволяют изменять типы, используемые классом.